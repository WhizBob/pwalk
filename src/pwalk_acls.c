// DESCRIPTION:  Adjunct code for pwalk(1) ACL-handling capability of translating POSIX ACLs
// in a source tree to NFS4 ACLs and applying them to a target file tree.

// DISCLAIMER:  The is FREE CODE for instructional purposes only.  There are no warranties,
// expressed or implied for this code, including any warrantees of correctness or suitability
// for any particular purpose.  Use at you own risk!

// NOTES: TODO & RFE ...
//	- Consider expanding named users and groups beyond UID and GID to have user@realm and SID options
//	- Consider changing ACL4 in-memory representation to use dynamic memory linked-list representation
//	- Refine 'BSD' output to show results more like what OneFS produces

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#ifdef __linux__
#include <linux/types.h>
#include <linux/nfs4.h>
#include <acl/libacl.h>
#else
#include <nfs/nfs.h>
#include <sys/acl.h>
#endif
#include <sys/stat.h>
#include <assert.h>

#define PWALK_ACLS_SOURCE 1	// Suppress conflicting extern decls
#include "pwalk_acls.h"		// Data types & function prototypes

// +++ SECRET DECODER RINGS +++

//CONVERT: PRIMARY REFERENCE: https://tools.ietf.org/html/draft-ietf-nfsv4-acl-mapping-05

//TRIVIALITY: [ From: https://manned.org/acl_is_trivial_np.3 - Gentoo BSD man pages ]
//TRIVIALITY:
//TRIVIALITY: - An ACL is trivial if it can be fully expressed as a file mode without loosing any access rules.
//TRIVIALITY: - For POSIX.1e ACLs, an ACL is trivial if it has the three required entries; one for owner, one
//TRIVIALITY:   for owning group, and one for other.
//TRIVIALITY: - For NFSv4 ACLs, an ACL is trivial if is identical to the ACL generated by acl_strip_np(3) from
//TRIVIALITY:   the file mode.
//TRIVIALITY: - Files that carry an explicit are shown with a plus sign appended after their mode bits in "ls -l"
//TRIVIALITY:   formatted output.

//NFS4:   type:flags:principal:permissions
//NFS4:
//NFS4:   [ From RFC 3530 (old NFS4 spec) and 7530 (new NFS4 spec) plus annotations ]
//NFS4:   [ (https://tools.ietf.org/html/<rfcnum>) ]
//NFS4:
//NFS4:   The NFS4 ACE structure is defined as follows:
//NFS4:
//NFS4:   typedef uint32_t        acetype4;
//NFS4:   typedef uint32_t        aceflag4;
//NFS4:   typedef uint32_t        acemask4;
//NFS4:   struct nfsace4 {
//NFS4:           acetype4                type;		// [ADUL]
//NFS4:           aceflag4                flags;	// [gdfinSF]
//NFS4:           acemask4                access_mask;	// [rwadDxocCnNtTy]
//NFS4:           utf8str_mixed           who;		// ASCII integer will be construed as UID/GID
//NFS4:   };
//NFS4:
//NFS4:   +----------------+---------------------------------------------------+
//NFS4:   | ACE 'who'      | Description                                       |
//NFS4:   +----------------+---------------------------------------------------+
//NFS4:   | <integer>      | A UID or GID value.                               |  // We just use these for POSIX
//NFS4:   | <user@realm>   | An unambiguous ID.                                |
//NFS4:   | OWNER@         | The owner of the file.                            |  // ACE4_IDENTIFIER_GROUP bit not used with these
//NFS4:   | GROUP@         | The group associated with the file.               |
//NFS4:   | EVERYONE@      | The world, including the owner and owning group.  |
//NFS4:   | INTERACTIVE@   | Accessed from an interactive terminal.            |
//NFS4:   | NETWORK@       | Accessed via the network.                         |
//NFS4:   | DIALUP@        | Accessed as a dialup user to the server.          |
//NFS4:   | BATCH@         | Accessed from a batch job.                        |
//NFS4:   | ANONYMOUS@     | Accessed without any authentication.              |
//NFS4:   | AUTHENTICATED@ | Any authenticated user (opposite of ANONYMOUS).   |
//NFS4:   | SERVICE@       | Access from a system service.                     |
//NFS4:   +----------------+---------------------------------------------------+
//NFS4:
//NFS4:   The constants used for the type field (acetype4) are as follows:
//NFS4:
//NFS4:   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;		// 'A' - Allow
//NFS4:   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;		// 'D' - Deny
//NFS4:   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;		// 'U' - aUdit
//NFS4:   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;		// 'L' - aLarm
//NFS4:
//NFS4:   All four bit types are permitted in the acetype4 attribute.
//NFS4:
//NFS4:   The bitmask constants used for aceflag4 attribute are as follows:
//NFS4:
//NFS4:   const ACE4_FILE_INHERIT_ACE             = 0x00000001;		// 'f' - propagate ACE to file in directory
//NFS4:   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;		// 'd' - propagate ACE to subdirectory
//NFS4:   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;		// 'n' - do not propagate inheritance
//NFS4:   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;		// 'i' - only inherit ACE; do not evaluate during access
//NFS4:   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;		// 'S' - trigger alarm/audit when permission Succeeds
//NFS4:   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;		// 'F' - trigger alarm/audit when permission Fails
//NFS4:   const ACE4_IDENTIFIER_GROUP             = 0x00000040;		// 'g' - 'who' specifies a gROUP
//NFS4:   const ACE4_INHERITED_ACE                = 0x00000080;		// n/a
//NFS4:
//NFS4:   The bitmask constants used for the access mask field are as follows:
//NFS4:
//NFS4:   const ACE4_READ_DATA            = 0x00000001;		// 'r' - can (r)ead the data of the file
//NFS4:   const ACE4_LIST_DIRECTORY       = 0x00000001;		// 'r' - can (r)ead the contents of the directory (not just traverse)
//NFS4:   const ACE4_WRITE_DATA           = 0x00000002;		// 'w' - can (w)rite the file's data
//NFS4:   const ACE4_ADD_FILE             = 0x00000002;		// 'w' - can create ((w)rite) a new file in the directory
//NFS4:   const ACE4_APPEND_DATA          = 0x00000004;		// 'a' - can (a)ppend data (write starting at EOF)
//NFS4:   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;		// 'a' - can (a)dd a subdirectory
//NFS4:   const ACE4_READ_NAMED_ATTRS     = 0x00000008;		// 'n' - can read (n)AMED attr of file or lookup named attrs directory
//NFS4:   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;		// 'N' - can write (N)amed attr of file or create named attrs directory
//NFS4:   const ACE4_EXECUTE              = 0x00000020;		// 'x' - can e(x)ecute file or traverse/search directory
//NFS4:   const ACE4_DELETE_CHILD         = 0x00000040;		// 'D' - can (D)elete file or directory within a directory
//NFS4:   const ACE4_READ_ATTRIBUTES      = 0x00000080;		// 't' - can read basic A(t)TRIBUTES (non-ACLs) of a file
//NFS4:   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;		// 'T' - can write basic a(T)tributes (non-ACLs) of a file
//NFS4:   const ACE4_DELETE               = 0x00010000;		// 'd' - can (d)elete file or directory
//NFS4:   const ACE4_READ_ACL             = 0x00020000;		// 'c' - can read A(c)L
//NFS4:   const ACE4_WRITE_ACL            = 0x00040000;		// 'C' - can write A(C)L
//NFS4:   const ACE4_WRITE_OWNER          = 0x00080000;		// 'o' - can write (o)wner and owner_group attributes
//NFS4:   const ACE4_SYNCHRONIZE          = 0x00100000;		// 'y' - can use object as s(y)nchronization primitive for IPC
//NFS4:
//NFS4:   [ NOTE: OneFS does not support ACE4_SYSTEM_AUDIT_ACE_TYPE & ACE4_SYSTEM_ALARM_ACE_TYPE ]
//NFS4:   [ ACES, nor are they convey-able from an existing POSIX ACL                            ]

//POSIX:   /* a_type field in acl_user_posix_entry_t */
//POSIX:   #define ACL_TYPE_ACCESS         (0x8000)		// ACL
//POSIX:   #define ACL_TYPE_DEFAULT        (0x4000)		// DACL
//POSIX:   
//POSIX:   /* e_tag entry in struct posix_acl_entry */
//POSIX:   #define ACL_USER_OBJ            (0x01)
//POSIX:   #define ACL_USER                (0x02)
//POSIX:   #define ACL_GROUP_OBJ           (0x04)
//POSIX:   #define ACL_GROUP               (0x08)
//POSIX:   #define ACL_MASK                (0x10)
//POSIX:   #define ACL_OTHER               (0x20)
//POSIX:   
//POSIX:   /* permissions in the e_perm field */
//POSIX:   #define ACL_READ                (0x04)		// 'r'
//POSIX:   #define ACL_WRITE               (0x02)		// 'w'
//POSIX:   #define ACL_EXECUTE             (0x01)		// 'x'
//POSIX:   //#define ACL_ADD               (0x08)
//POSIX:   //#define ACL_DELETE            (0x10)
//POSIX:   
//POSIX:   struct posix_acl_entry {				// ACE
//POSIX:           short                   e_tag;
//POSIX:           unsigned short          e_perm;		// 'rwx'
//POSIX:           union {
//POSIX:                   kuid_t          e_uid;
//POSIX:                   kgid_t          e_gid;
//POSIX:                   int             e_id;		// -1 unknown, -2 nobody
//POSIX:           };
//POSIX:   };
//POSIX:   
//POSIX:   struct posix_acl {					// ACL
//POSIX:           union {
//POSIX:                   atomic_t                a_refcount;
//POSIX:                   struct rcu_head         a_rcu;
//POSIX:           };
//POSIX:           unsigned int            a_count;		// # ACEs
//POSIX:           struct posix_acl_entry  a_entries[0];	// ACEs
//POSIX:   }; 

// ^^^ <end> SECRET DECODER RINGS <end> ^^^

// The following MACRO makes the error handling simpler (REQUIRES context with emsg_p, err_p,
// retval, and 'out:' all defined);
#define PW_ACL_ERR(x) { if (emsg_p) strcpy(emsg_p,x); if (err_p) *err_p=errno; retval = -1; goto out; }

// format_mode_bits() - translate passed st_mode value into 'rwx' format in passed buffer
// NOTE: local static version, slightly different from the one in pwalk.c.

static void
format_mode_bits(char *str, mode_t mode)
{

   switch (mode & S_IFMT) {
   case S_IFIFO:  str[0] = 'p'; break;
   case S_IFCHR:  str[0] = 'c'; break;
   case S_IFDIR:  str[0] = 'd'; break;
   case S_IFBLK:  str[0] = 'b'; break;
   case S_IFREG:  str[0] = '-'; break;
   case S_IFLNK:  str[0] = 'l'; break;
   case S_IFSOCK: str[0] = 's'; break;
#ifdef S_IFDOOR
   case S_IFDOOR: str[0] = 'D'; break;
#endif
   default:       str[0] = '?';
   }

   str[1] = (mode & S_IRUSR) ? 'r' : '-';
   str[2] = (mode & S_IWUSR) ? 'w' : '-';
   str[3] = (mode & S_IXUSR) ? 'x' : '-';
   if (mode & S_ISUID) str[3] = (str[3] == '-') ? 'S' : 's';

   str[4] = (mode & S_IRGRP) ? 'r' : '-';
   str[5] = (mode & S_IWGRP) ? 'w' : '-';
   str[6] = (mode & S_IXGRP) ? 'x' : '-';
   if (mode & S_ISGID) str[6] = (str[6] == '-') ? 'S' : 's';

   str[7] = (mode & S_IROTH) ? 'r' : '-';
   str[8] = (mode & S_IWOTH) ? 'w' : '-';
   str[9] = (mode & S_IXOTH) ? 'x' : '-';
   if (mode & S_ISVTX) str[9] = (str[9] == '-') ? 'T' : 't';

   str[10] = '\0';
}

// pw_acl_ace4_sprintf() - Format passed ACL4 into the passed buffer using nfs4_setfacl coding.
// NOTE: No shorthand used in this translation, but this code does address the general case.
// WARNING: No bounds-checking!  klooge!  SUGGESTED: Pass in a 64-byte buffer!
//
// NOTE: The CITI NFS Tools letter abbrevations overload some letters between the mask and flags values.
// For example, 'd' could mean ACE4_DIRECTORY_INHERIT_ACE or ACE4_DELETE.  Therefore, the full range of
// ACL expressions cannot be expressed using this syntax.

static void
pw_acl_ace4_sprintf(char *acl_str, ace4_t *ace4)
{
    char *dst;
    int i;
    unsigned maskval;

    dst = acl_str;
    // <ace4 type> ...
    if      (ace4->type == ACE4_ACCESS_ALLOWED_ACE_TYPE) *dst++ = 'A';	// Allow
    else if (ace4->type == ACE4_ACCESS_DENIED_ACE_TYPE ) *dst++ = 'D';	// Deny
    else if (ace4->type == ACE4_SYSTEM_AUDIT_ACE_TYPE  ) *dst++ = 'U';	// aUdit
    else if (ace4->type == ACE4_SYSTEM_ALARM_ACE_TYPE  ) *dst++ = 'L';	// aLarm
    else                                                 *dst++ = '?';	// WTF?
    *dst++ = ':';

    // <ace4 who> ... (With NFS4 special identities)
    dst += sprintf(dst, "%s:", ace4->who);

    // <ace4 flags> ...
    if (ace4->flags & ACE4_FILE_INHERIT_ACE          ) *dst++ = 'f';	// propagate ACE to file in directory
    if (ace4->flags & ACE4_DIRECTORY_INHERIT_ACE     ) *dst++ = 'd';	// propagate ACE to subdirectory
    if (ace4->flags & ACE4_NO_PROPAGATE_INHERIT_ACE  ) *dst++ = 'n';	// do not propagate inheritance
    if (ace4->flags & ACE4_INHERIT_ONLY_ACE          ) *dst++ = 'i';	// only inherit ACE; do not evaluate during access
    if (ace4->flags & ACE4_SUCCESSFUL_ACCESS_ACE_FLAG) *dst++ = 'S';	// trigger alarm/audit when permission Succeeds
    if (ace4->flags & ACE4_FAILED_ACCESS_ACE_FLAG    ) *dst++ = 'F';	// trigger alarm/audit when permission Fails
    if (ace4->flags & ACE4_IDENTIFIER_GROUP          ) *dst++ = 'g';	// 'who' specifies a gROUP

    // <ace4 mask> ...
    maskval = ace4->mask;					// For (future) subtractive translation
    if (maskval & ACE4_READ_DATA        ) *dst++ = 'r';		// can (r)ead the data of the file
    if (maskval & ACE4_WRITE_DATA       ) *dst++ = 'w';		// can (w)rite the file's data
    if (maskval & ACE4_APPEND_DATA      ) *dst++ = 'a';		// can (a)ppend data (write starting at EOF)
    if (maskval & ACE4_READ_NAMED_ATTRS ) *dst++ = 'n';		// can read (n)AMED attr of file or lookup named attrs directory
    if (maskval & ACE4_WRITE_NAMED_ATTRS) *dst++ = 'N';		// can write (N)amed attr of file or create named attrs directory
    if (maskval & ACE4_EXECUTE          ) *dst++ = 'x';		// can e(x)ecute file or traverse/search directory
    if (maskval & ACE4_DELETE_CHILD     ) *dst++ = 'D';		// can (D)elete file or directory within a directory
    if (maskval & ACE4_READ_ATTRIBUTES  ) *dst++ = 't';		// can read basic A(t)TRIBUTES (non-ACLs) of a file
    if (maskval & ACE4_WRITE_ATTRIBUTES ) *dst++ = 'T';		// can write basic a(T)tributes (non-ACLs) of a file
    if (maskval & ACE4_DELETE           ) *dst++ = 'd';		// can (d)elete file or directory
    if (maskval & ACE4_READ_ACL         ) *dst++ = 'c';		// can read A(c)L
    if (maskval & ACE4_WRITE_ACL        ) *dst++ = 'C';		// can write A(C)L
    if (maskval & ACE4_WRITE_OWNER      ) *dst++ = 'o';		// can write (o)wner and owner_group attributes
    if (maskval & ACE4_SYNCHRONIZE      ) *dst++ = 'y';		// can use object as s(y)nchronization primitive for IPC

    // <fini>
    *dst = '\0';
}

void
pw_acl4_fprintf_nfs4_setfacl(acl4_t *acl4p, const char *path, FILE *stream)
{
    char ace4_string[64];
    int i;

    // Print ACL4 as nfs4_setfacl command ...
    if (acl4p->n_aces == 0)
        return;
    fprintf(stream, "nfs4_setfacl ");
    for (i=0; i < acl4p->n_aces; i++) {
        if (i > 0) fprintf(stream, ",");
        pw_acl_ace4_sprintf(ace4_string, acl4p->ace4 + i);
        fprintf(stream, "%s", ace4_string);
    }
    fprintf(stream, " \"%s\"\n", path);
}

void
pw_acl4_fprintf_chex(acl4_t *acl4p, const char *path, stat_t *sb_p, FILE *stream)
{
    int n_ace;
    char mode_s[16], type;
    int mask, flags;
    char trustee[64];

    // Nothing to do?
    if (acl4p == NULL || acl4p->n_aces == 0)
        return;

    // Output path semi-ls-l-like ...
    if (path && path[0]) {
        format_mode_bits(mode_s, sb_p->st_mode);
        fprintf(stream, "%s %d %3d %3d %6lld %s\n",
                mode_s, sb_p->st_nlink, sb_p->st_uid, sb_p->st_gid, sb_p->st_size, path);
    }

    // Dump ACL4 binary contents ...
    for (n_ace=0; n_ace < acl4p->n_aces; n_ace++) {
        if (acl4p->ace4[n_ace].type == ACE4_ACCESS_ALLOWED_ACE_TYPE) type = 'A';
        else if (acl4p->ace4[n_ace].type == ACE4_ACCESS_DENIED_ACE_TYPE) type = 'D';
        else if (acl4p->ace4[n_ace].type == ACE4_SYSTEM_AUDIT_ACE_TYPE) type = 'U';
        else if (acl4p->ace4[n_ace].type == ACE4_SYSTEM_ALARM_ACE_TYPE) type = 'L';
        else type = '?';
        mask = acl4p->ace4[n_ace].mask;
        flags = acl4p->ace4[n_ace].flags;
        strcpy(trustee, acl4p->ace4[n_ace].who);	// klooge: unprotected
        if (strcmp("OWNER@", trustee) == 0)				// owner
            sprintf(trustee, "user:%d <owner-uid>", sb_p->st_uid);
        else if (strcmp("GROUP@", trustee) == 0)			// group
            sprintf(trustee, "group:%d <group-gid>", sb_p->st_gid);
        else if (strcmp("EVERYONE@", trustee) == 0)			// everyone
            strcpy(trustee, "everyone");
        else if (acl4p->ace4[n_ace].flags & ACE4_IDENTIFIER_GROUP)	// group:<string>
            sprintf(trustee, "group:%s", acl4p->ace4[n_ace].who);
        else								// user:<string>
            sprintf(trustee, "user:%s", acl4p->ace4[n_ace].who);
        fprintf(stream, " %d: %c %06x.%02x %s\n", n_ace, type, mask, flags, trustee);
    }
}

// pw_acl_ace4_sprintf_onefs() - Format passed NFS4 ACE into passed string buffer using OneFS coding.
// Passed-in stat() info used to determine if we're doing a file or directory, and also to reference
// object's UID and GID values.
// WARNING: No bounds-checking!  klooge!  SUGGESTED: Pass in a 256-byte buffer!

static void
pw_acl_ace4_sprintf_onefs(char *acl_str, ace4_t *ace4, stat_t *sb_p)
{
    char *p;
    int i;
    unsigned maskval, mask_done;

    p = acl_str;

    // <ace4 who> will be one of ...
    //		OWNER@ (file) -> user:<owner-uid=%d>
    //		<n> (!ACE4_IDENTIFIER_GROUP) -> user:<uid=n>
    //		OWNER@ (dir) -> SID:S-1-3-0 (creator_owner)
    //		GROUP@ (file) -> group:<owner-gid=%d>
    //		<n> (ACE4_IDENTIFIER_GROUP) -> group:<gid=n>
    //		GROUP@ (dir) -> SID:S-1-3-1 (creator_group)
    //		EVERYONE@ -> SID:S-1-1-0 (everyone)
    if (ace4->who[0] == 'E') {				// EVERYONE@
        p += sprintf(p, "SID:S-1-1-0 ");
    } else if (isdigit(ace4->who[0])) {			// named (numeric) ...
        if (ace4->flags & ACE4_IDENTIFIER_GROUP) {
            p += sprintf(p, "group:%s ", ace4->who);	// ... group.
        } else {
	    p += sprintf(p, "user:%s ", ace4->who);	// ... user.
        }
    } else if (ace4->who[0] == 'O') {			// OWNER@
        if (S_ISDIR(sb_p->st_mode) && (ace4->flags & ACE4_INHERIT_ONLY_ACE))
	    p += sprintf(p, "SID:S-1-3-0 ");
        else
            p += sprintf(p, "user:<owner-uid=%d> ", sb_p->st_uid);
    } else if (ace4->who[0] == 'G') {			// GROUP@
        if (S_ISDIR(sb_p->st_mode) && (ace4->flags & ACE4_INHERIT_ONLY_ACE))
	    p += sprintf(p, "SID:S-1-3-1 ");
        else
            p += sprintf(p, "group:<owner-gid=%d> ", sb_p->st_gid);
    }

    // <ace4 type> (allow or deny) ...
    if      (ace4->type == ACE4_ACCESS_ALLOWED_ACE_TYPE) p += sprintf(p, "allow ");
    else if (ace4->type == ACE4_ACCESS_DENIED_ACE_TYPE ) p += sprintf(p, "deny ");
    else                                                 p += sprintf(p, "? ");	// klooge: we only handle allow+deny

    // <ace4 mask> ...
    maskval = ace4->mask & ACE4_MASK_ALL;		// For subtractive translation (most-expressive-to-least)
    mask_done = 0;

#if (0)	// DEVELOPMENTAL; need to expunge ONEFS_* references
    // STEP #1: Do GENERIC mask bit groupings ...
    if (S_ISDIR(sb_p->st_mode)) {
        if ((maskval & ONEFS_dir_gen_all) == ONEFS_dir_gen_all) {
            p += sprintf(p, "dir_gen_all,"); mask_done = ONEFS_dir_gen_all;
        } else {
            if ((maskval & ONEFS_dir_gen_read) == ONEFS_dir_gen_read) {
                p += sprintf(p, "dir_gen_read,"); mask_done |= ONEFS_dir_gen_read;
            } 
            if ((maskval & ONEFS_dir_gen_write) == ONEFS_dir_gen_write) {
                p += sprintf(p, "dir_gen_write,"); mask_done |= ONEFS_dir_gen_write;
            } 
            if ((maskval & ONEFS_dir_gen_execute) == ONEFS_dir_gen_execute) {
                p += sprintf(p, "dir_gen_execute,"); mask_done |= ONEFS_dir_gen_execute;
            } 
        } 
    } else {
        if ((maskval & ONEFS_file_gen_all) == ONEFS_file_gen_all) {
            p += sprintf(p, "file_gen_all,"); mask_done = ONEFS_file_gen_all;
        } else {
            if ((maskval & ONEFS_file_gen_read) == ONEFS_file_gen_read) {
                p += sprintf(p, "file_gen_read,"); mask_done |= ONEFS_file_gen_read;
            } 
            if ((maskval & ONEFS_file_gen_write) == ONEFS_file_gen_write) {
                p += sprintf(p, "file_gen_write,"); mask_done |= ONEFS_file_gen_write;
            } 
            if ((maskval & ONEFS_file_gen_execute) == ONEFS_file_gen_execute) {
                p += sprintf(p, "file_gen_execute,"); mask_done |= ONEFS_file_gen_execute;
            } 
        } 
    }
    maskval &= (~mask_done & ACE4_MASK_ALL); // TAKE AWAY bits we've already expressed ...

    // STEP #2: For non-directories, see if BSD 'modify' matches ...
    if (!S_ISDIR(sb_p->st_mode)) {
        if ((maskval & ONEFS_modify) == ONEFS_modify) {
            p += sprintf(p, "modify,"); mask_done |= ONEFS_modify;
            maskval &= (~mask_done & ACE4_MASK_ALL); // TAKE AWAY bits we've already expressed ...
        }
    }

    // STEP #3: See if 'std_required' matches ...
    if ((maskval & ONEFS_std_required) == ONEFS_std_required) {
        p += sprintf(p, "std_required,"); mask_done |= ONEFS_std_required;
        maskval &= (~mask_done & ACE4_MASK_ALL); // TAKE AWAY bits we've already expressed ...
    }
#endif // (0) DEVELOPMENTAL

    // STEP #4: Match remaining 14 individual permissions ...
    if (S_ISDIR(sb_p->st_mode)) {
        if (maskval & ACE4_LIST_DIRECTORY   ) p += sprintf(p, "list,");
        if (maskval & ACE4_ADD_FILE         ) p += sprintf(p, "add_file,");
        if (maskval & ACE4_ADD_SUBDIRECTORY ) p += sprintf(p, "add_subdir,");
        if (maskval & ACE4_READ_NAMED_ATTRS ) p += sprintf(p, "dir_read_ext_attr,");
        if (maskval & ACE4_WRITE_NAMED_ATTRS) p += sprintf(p, "dir_write_ext_attr,");
        if (maskval & ACE4_EXECUTE          ) p += sprintf(p, "traverse,");
        if (maskval & ACE4_DELETE_CHILD     ) p += sprintf(p, "delete_child,");
        if (maskval & ACE4_READ_ATTRIBUTES  ) p += sprintf(p, "dir_read_attr,");
        if (maskval & ACE4_WRITE_ATTRIBUTES ) p += sprintf(p, "dir_write_attr,");
        if (maskval & ACE4_DELETE           ) p += sprintf(p, "std_delete,");
        if (maskval & ACE4_READ_ACL         ) p += sprintf(p, "std_read_dac,");
        if (maskval & ACE4_WRITE_ACL        ) p += sprintf(p, "std_write_dac,");
        if (maskval & ACE4_WRITE_OWNER      ) p += sprintf(p, "std_write_owner,");
        if (maskval & ACE4_SYNCHRONIZE      ) p += sprintf(p, "std_synchronize,");
    } else {
        if (maskval & ACE4_READ_DATA        ) p += sprintf(p, "file_read,");
        if (maskval & ACE4_WRITE_DATA       ) p += sprintf(p, "file_write,");
        if (maskval & ACE4_APPEND_DATA      ) p += sprintf(p, "append,");
        if (maskval & ACE4_READ_NAMED_ATTRS ) p += sprintf(p, "file_read_ext_attr,");
        if (maskval & ACE4_WRITE_NAMED_ATTRS) p += sprintf(p, "file_write_ext_attr,");
        if (maskval & ACE4_EXECUTE          ) p += sprintf(p, "execute,");
        if (maskval & ACE4_DELETE_CHILD     ) p += sprintf(p, "delete_child,");		// meaningless, but settable
        if (maskval & ACE4_READ_ATTRIBUTES  ) p += sprintf(p, "file_read_attr,");
        if (maskval & ACE4_WRITE_ATTRIBUTES ) p += sprintf(p, "file_write_attr,");
        if (maskval & ACE4_DELETE           ) p += sprintf(p, "std_delete,");
        if (maskval & ACE4_READ_ACL         ) p += sprintf(p, "std_read_dac,");
        if (maskval & ACE4_WRITE_ACL        ) p += sprintf(p, "std_write_dac,");
        if (maskval & ACE4_WRITE_OWNER      ) p += sprintf(p, "std_write_owner,");
        if (maskval & ACE4_SYNCHRONIZE      ) p += sprintf(p, "std_synchronize,");
    }

    // <ace4 flags> ... Only for directories in this context.
    // NOTE: "inherited_ace - ... NEVER occurs in this context.
    // NOTE: "inherit_only - ... (DACL-derived ACE) ALWAYS occurs in this context.
    if (S_ISDIR(sb_p->st_mode)) {
        if (ace4->flags & ACE4_FILE_INHERIT_ACE          ) p += sprintf(p, "object_inherit,");
        if (ace4->flags & ACE4_DIRECTORY_INHERIT_ACE     ) p += sprintf(p, "container_inherit,");
        if (ace4->flags & ACE4_NO_PROPAGATE_INHERIT_ACE  ) p += sprintf(p, "no_prop_inherit,");
        if (ace4->flags & ACE4_INHERIT_ONLY_ACE          ) p += sprintf(p, "inherit_only,");
        if (ace4->flags & ACE4_INHERITED_ACE             ) p += sprintf(p, "inherited,");
    }

    // Trim possible trailing comma ...
    if (*(p-1) == ',') *(p-1) = '\0';
}

// Show ACL4 as we expect BSD/OneFS 'ls -lend' would show it ...

void
pw_acl4_fprintf_onefs(acl4_t *acl4p, const char *path, struct stat *sb_p, FILE *stream)
{
    char ace4_string[256];
    char mode_s[16], type;
    int i;

    // Nothing to do?
    if (acl4p == NULL || acl4p->n_aces == 0)
        return;

    // // Output path semi-ls-l-like ...
    // format_mode_bits(mode_s, sb_p->st_mode);
    // if (path && path[0]) fprintf(stream, "%s %d %3d %3d %6lld %s\n",
    //    mode_s, sb_p->st_nlink, sb_p->st_uid, sb_p->st_gid, sb_p->st_size, path);

    // Output chmod -E preamble ...
    if (path && path[0]) {
        fprintf(stream, "chown %d:%d %s\n", sb_p->st_uid, sb_p->st_gid, path);
        fprintf(stream, "chmod -E %s <<END\n", path);
    }

    // Format each ACE in sequence ...
    for (i=0; i < acl4p->n_aces; i++) {
        if (acl4p->ace4[i].type == ACE4_ACCESS_ALLOWED_ACE_TYPE) type = 'A';
        else if (acl4p->ace4[i].type == ACE4_ACCESS_DENIED_ACE_TYPE) type = 'D';
        else if (acl4p->ace4[i].type == ACE4_SYSTEM_AUDIT_ACE_TYPE) type = 'U';
        else if (acl4p->ace4[i].type == ACE4_SYSTEM_ALARM_ACE_TYPE) type = 'L';
        else type = '?';
        //fprintf(stream, "%d: %c %06x.%02x %s\n", i, type, acl4p->ace4[i].mask, acl4p->ace4[i].flags, acl4p->ace4[i].who);
        pw_acl_ace4_sprintf_onefs(ace4_string, acl4p->ace4 + i, sb_p);
        fprintf(stream, " %d: %s\n", i, ace4_string);
    }
    if (path && path[0]) fprintf(stream, "END\n");
}

// CANONICALIZATION FUNCTIONS ...
//
// Using MT-safe version of qsort ...
//
//       void qsort_r(void *base, size_t nmemb, size_t size,
//                  int (*compar)(const void *, const void *, void *),
//                  void *arg);
//
// Basic canonicalization order ...
//	1.	OWNER@ DENY
//	2.	OWNER@ ALLOW
//	3.	named user DENY
//	4.	named user ALLOW
//	5.	GROUP@ ALLOW
//	6.	named group ALLOW
//	7.	GROUP@ DENY
//	8.	named group DENY
//	9.	EVERYONE@
//	10.	In addition, all DACL ACEs are ordered AFTER all ACL ACEs by adding 100 to their weighting.
//
// NOTE: This code is simplified by only needing to deal with NUMERIC named groups and users.
// The only non-numeric IDs we encounter are for OWNER@, GROUP@, and EVERYONE@ trustees.

// pw_acl_sort_ace_value() - Used to assign a sort weighting value to an ACE4.

static int
pw_acl_sort_ace_value(ace4_t *ace4p)
{
    int dacl;

    dacl = (ace4p->flags & ACE4_INHERIT_ONLY_ACE) ? 100 : 0;
    if (ace4p->who[0] == 'E') {					// EVERYONE@
        return(9 + dacl);
    } else if (ace4p->who[0] == 'O') {
        if (ace4p->type == ACE4_ACCESS_DENIED_ACE_TYPE)		// OWNER@ DENY
            return (1 + dacl);
        if (ace4p->type == ACE4_ACCESS_ALLOWED_ACE_TYPE)	// OWNER@ ALLOW
            return (2 + dacl);
        else
            return (1000 + dacl);
    } else if (ace4p->who[0] == 'G') {
        if (ace4p->type == ACE4_ACCESS_ALLOWED_ACE_TYPE)	// GROUP@ ALLOW
            return (5 + dacl);
        else if (ace4p->type == ACE4_ACCESS_DENIED_ACE_TYPE)	// GROUP@ DENY
            return (7 + dacl);
        else
            return (1000 + dacl);
    } else if (ace4p->flags & ACE4_IDENTIFIER_GROUP) {
        if (ace4p->type == ACE4_ACCESS_ALLOWED_ACE_TYPE)	// named group ALLOW
            return (6 + dacl);
        else if (ace4p->type == ACE4_ACCESS_DENIED_ACE_TYPE)	// named group DENY
            return (8 + dacl);
        else
            return (1000 + dacl);
    } else {
        if (ace4p->type == ACE4_ACCESS_DENIED_ACE_TYPE)		// named user DENY
            return (3 + dacl);
        else if (ace4p->type == ACE4_ACCESS_ALLOWED_ACE_TYPE)	// named user ALLOW
            return (4 + dacl);
        else
            return (1000 + dacl);
    }
}

// pw_acl_sort_f() - Used for canonicalization qsort() call.

static int
pw_acl_sort_f(ace4_t *ace1p, ace4_t *ace2p, void *arg)
{

    return (pw_acl_sort_ace_value(ace1p) - pw_acl_sort_ace_value(ace2p));
}

// pw_acl4_canonicalize() - Exposed as an external entry.

void
pw_acl4_canonicalize(acl4_t *acl4)
{
    void *arg;

    qsort_r(acl4->ace4, acl4->n_aces, sizeof(ace4_t), pw_acl_sort_f, &arg);
}

// zeropad() - fill out passed field with NUL bytes after 1st NUL byte

static void
zeropad(char *str, int nbytes)
{
    int i;
    int nulseen = 0;

    if (str == NULL || nbytes <= 0) return;
    for (i=0; i<nbytes; i++) {
        if (nulseen) str[i] = '\0';
        else if (str[i] == '\0') nulseen = 1;
    }
}

// *** vvv THE NEXT TWO FUNCTIONS ARE THE MAIN SUBSTANCE OF WHAT ALL THIS CODE IS REALLY ABOUT vvv ***

// NOTE: the scope of all dynamic POSIX ACL values is limited to the next two functions, and the only
// return path each is at the end, after all such values are acl_free()'d.

// NOTE: these functions must normally emit no output!

// pw_acl_xlat_add_posix_acl_to_acl4() - Called twice to accumulate ACL and DACL translations into
// a single ACL4. Caller must pass dacl_flag to distinguish ACL from DACL.	(REF: 5.)
//
// RETURNS: Number of ACL4 ACEs added, or -1 on any error.
//
// CAUTION: This function MUST be called first for a DACL then for the ACL! Trivial ACLs are NOT ignored
// when a DACL is present, because they must be integrated into the resulting NFS4 ACL.

static int
pw_acl_xlat_add_posix_acl_to_acl4(const acl_t *posix_acl_p, const int dacl_flag, const int dir_flag, acl4_t *acl4p, char *emsg_p, int *err_p)
{
    int i, rc, retval;

    // POSIX ACL info ...
    acl_entry_t posix_ace;
    acl_tag_t posix_acl_tag;
    void *acl_qualifier_p;			// must be acl_free()'d after each use
    acl_permset_t posix_ace_permset;
    mode_t posix_mask;
    int posix_ace_id;
    uid_t uid;
    gid_t gid;
    mode_t posix_ace_maskval, posix_mask_ace_mask, posix_other_ace_mask;
    static unsigned posix_types[PW_ACL_MAX_ACE4];
    static unsigned posix_masks[PW_ACL_MAX_ACE4];
    int posix_acl_is_trivial = 1;		// assume 'yes' to start
    char who4_tmp[16];				// Temp
    int i_allow_first, i_allow_last;		// index to first and last ace4 values added
    int n_allow_aces = 0, n_deny_aces = 0;	// sum is return value
    ace4_t *ace4p;				// pointer ro current ace4
    int has_dacl = 0;				// KEEP trivial ACLs when DACL is present

    // Nothing to do??
    if (posix_acl_p == NULL || *posix_acl_p == NULL)
        return (0);

    // Take note: we will NOT skip a trivial ACL when a DACL is present ...
    has_dacl = (!dacl_flag && (acl4p->n_aces > 0));

    // *** PASS 1 *** - Iterate over POSIX ACL or DACL ACEs, creating preliminary NFS4 ACEs ...

    if (pw_acls_DEBUGin) printf("DEBUG: Adding ACE4 entries from POSIX %s ...\n", dacl_flag ? "DACL" : "ACL");
    for (posix_ace_id = ACL_FIRST_ENTRY;; posix_ace_id = ACL_NEXT_ENTRY) {
	rc = acl_get_entry(*posix_acl_p, posix_ace_id, &posix_ace);
        if (rc == 0) break;		// No more entries ...
        if (rc != 1) PW_ACL_ERR("acl_get_entry()");

	// Retrieve posix_acl_tag and qualifier value ...
	if (acl_get_tag_type(posix_ace, &posix_acl_tag) == -1)
	    PW_ACL_ERR("acl_get_tag_type()");
	acl_qualifier_p = acl_get_qualifier(posix_ace);		// NULL if 'none' (must acl_free())

        // Calculate perms mask (or POSIX 'mask ACE' mask value) ...
	if (acl_get_permset(posix_ace, &posix_ace_permset) != 0)
	    PW_ACL_ERR("acl_get_permset()");
        posix_ace_maskval = 0;
        if (acl_get_perm(posix_ace_permset, ACL_READ) == 1) posix_ace_maskval |= 4;
        if (acl_get_perm(posix_ace_permset, ACL_WRITE) == 1) posix_ace_maskval |= 2;
        if (acl_get_perm(posix_ace_permset, ACL_EXECUTE) == 1) posix_ace_maskval |= 1;

	// Create single ACE4 for each POSIX ACE (except for 'mask ACE') ...
	posix_mask_ace_mask = 7;							// REF: 1. (default)
	switch (posix_acl_tag) {
        case ACL_USER_OBJ:
            strcpy(who4_tmp, "OWNER@");
            break;
	case ACL_USER:
	    if (acl_qualifier_p != NULL) {
                uid = *(uid_t *) acl_qualifier_p;
                sprintf(who4_tmp, "%d", uid);
                posix_acl_is_trivial = 0;		// Not any more!
            }
            break;
        case ACL_GROUP_OBJ:
            strcpy(who4_tmp, "GROUP@");
            break;
        case ACL_GROUP:
	    if (acl_qualifier_p != NULL) {
		gid = *(gid_t *) acl_qualifier_p;
                sprintf(who4_tmp, "%d", gid);
                posix_acl_is_trivial = 0;		// Not any more!
	    }
            break;
        case ACL_MASK:
	    posix_mask_ace_mask = posix_ace_maskval;					// REF: 1.
            if (pw_acls_DEBUGin) printf("DEBUG: SET posix_mask_ace_mask=%d\n", posix_mask_ace_mask);
	    acl_free(acl_qualifier_p);
            continue;	// Skip out to next ACE!
        case ACL_OTHER:
            strcpy(who4_tmp, "EVERYONE@");
            posix_other_ace_mask = posix_ace_maskval;					// REF: 2.2.3. (prep)
            break;
	default:
            PW_ACL_ERR("Unknown POSIX tag value!");
	}
	acl_free(acl_qualifier_p);
        if (pw_acls_DEBUGin) printf("DEBUG: ACE who=%s mask=0%o\n", who4_tmp, posix_ace_maskval);

        // Add an ACE4, capturing info for PASS 2 in congruent posix_* arrays ...
        if (acl4p->n_aces >= PW_ACL_MAX_ACE4) {
            errno = E2BIG;
            PW_ACL_ERR("PW_ACL_MAX_ACE4 overflow");
        }
        posix_types[acl4p->n_aces] = posix_acl_tag;					// REF: 2.4.1. (prep)
        posix_masks[acl4p->n_aces] = posix_ace_maskval;					// REF: 2.4.1. (prep)
        ace4p = acl4p->ace4 + acl4p->n_aces;
        strcpy(ace4p->who, who4_tmp);							// REF: 2.2. (numeric only!)
        zeropad(ace4p->who, sizeof(ace4p->who));
        acl4p->n_aces += 1;
        n_allow_aces += 1;
    }

    // PASS 1a: Skip (backup) over a trivial ACL unless a DACL is present, in which case we retain the ACL ACEs ...
    if (!dacl_flag && posix_acl_is_trivial && !has_dacl) {
        acl4p->n_aces -= n_allow_aces;
        n_allow_aces = 0;
    }

    // PASS 2: Iterate over nascent NFS4 ALLOW ACEs, translating POSIX ACEs one-for-one ...
    i_allow_first = acl4p->n_aces - n_allow_aces;
    i_allow_last = acl4p->n_aces - 1;
    for (i = i_allow_first; i <= i_allow_last; i++) {
        // <acetype4> ...
        acl4p->ace4[i].type = ACE4_ACCESS_ALLOWED_ACE_TYPE;				// REF: 2.1.

        // <aceflag4> ...
        acl4p->ace4[i].flags = 0;
        // ... named non-GROUP@ trustee ...						// REF: 2.3.1
        if (isdigit(acl4p->ace4[i].who[0]) && ((posix_types[i] == ACL_GROUP) || (posix_types[i] == ACL_GROUP_OBJ)))
            acl4p->ace4[i].flags |= ACE4_IDENTIFIER_GROUP;
        if (strcmp(acl4p->ace4[i].who, "GROUP@") == 0 && !dacl_flag)			// REF: 2.3.1-AMENDED
            acl4p->ace4[i].flags |= ACE4_IDENTIFIER_GROUP;
        // ... POSIX DACL (inheritable) ACE ...						// REF: 2.3.2.
        if (dacl_flag)
            acl4p->ace4[i].flags |= (ACE4_INHERIT_ONLY_ACE|ACE4_DIRECTORY_INHERIT_ACE|ACE4_FILE_INHERIT_ACE);

        // <acemask4> (POSIX mask does NOT apply to OWNER@ and GROUP@ ACEs) ...
        if (posix_types[i] == ACL_USER ||						// REF: 2.4.1.
            posix_types[i] == ACL_GROUP ||
            posix_types[i] == ACL_GROUP_OBJ
           ) {
            posix_masks[i] &= posix_mask_ace_mask;	// Apply 'mask ACE' mask
        }
        acl4p->ace4[i].mask = (ACE4_READ_ACL|ACE4_READ_ATTRIBUTES|ACE4_SYNCHRONIZE);	// REF: 2.4.2
        if (posix_masks[i] & 4)								// REF: 2.4.3. (ACL_READ)
            acl4p->ace4[i].mask |= ACE4_READ_DATA;
        if (posix_masks[i] & 2)								// REF: 2.4.4. (ACL_WRITE)
            acl4p->ace4[i].mask |= (ACE4_WRITE_DATA|ACE4_APPEND_DATA|ACE4_DELETE|
               (dir_flag ? ACE4_DELETE_CHILD : 0));
        if (posix_masks[i] & 1)								// REF: 2.4.5. (ACL_EXECUTE)
            acl4p->ace4[i].mask |= ACE4_EXECUTE;
        if (strcmp(acl4p->ace4[i].who, "OWNER@") == 0)					// REF: 2.4.6.
            acl4p->ace4[i].mask |= (ACE4_WRITE_ACL|ACE4_WRITE_ATTRIBUTES);
    }

    if (pw_acls_DEBUGout) printf("DEBUG: *S %d ACL4 ALLOW ACEs created from %s\n", n_allow_aces, dacl_flag ? "DACL" : "ACL");
    if (n_allow_aces == 0) return (0);	// No DENY ACEs needed

    // PASS 3: Add DENY ACEs ...							// REF: 4.*.
    for (i = i_allow_first; i <= i_allow_last; i++) {
        if ((posix_masks[i] | posix_other_ace_mask) == posix_masks[i])
            continue;
        // Adding a DENY ACE ...
        ace4p = acl4p->ace4 + acl4p->n_aces;
        // <acetype4> ...								// REF: 4.1.
        ace4p->type = ACE4_ACCESS_DENIED_ACE_TYPE;
        // <aceflag4> ...								// REF: 4.1.1 (flags)
        ace4p->flags = acl4p->ace4[i].flags;
        // <acemask4> ...								// REF: 4.1.2.
        ace4p->mask = ~(acl4p->ace4[i].mask);
        ace4p->mask &= ~(ACE4_WRITE_OWNER|ACE4_DELETE|ACE4_READ_NAMED_ATTRS|ACE4_WRITE_NAMED_ATTRS);
        if (!dir_flag) ace4p->mask &= ~(ACE4_DELETE_CHILD);
        ace4p->mask &= ACE4_MASK_ALL;							// REF: 4.1.3.
        // <ace4 who>									// REF: 4.1.1. (who)
        strcpy(ace4p->who, acl4p->ace4[i].who);
        zeropad(ace4p->who, sizeof(ace4p->who));

        acl4p->n_aces += 1;
        n_deny_aces += 1;
    }
    if (pw_acls_DEBUGout) printf("DEBUG: %d ACL4 DENY ACEs created from %s\n", n_deny_aces, dacl_flag ? "DACL" : "ACL");

    // Successful finish ...
    retval = n_allow_aces + n_deny_aces;
out:
    return (retval);
}

// pw_acl4_get_from_posix_acls() - Returns total NFS4 ACEs produced in the translation, or -1 on any error.
// In this context, "POSIX ACLs" (plural) means the 'POSIX ACL plus POSIX DACL', as both are merged into a 
// single NFS4 ACL.
//
// Returned 'aclstat' is a bitmask;
//	0x01 Has trivial ACL
//	0x02 Has non-trivial ACL
//	0x04 Has DACL
//
// MT-safe; caller must provide a 64-byte error message buffer and an int to receive error text and
// corresponding errno value in the event of any errors (or may pass NULL for either.  Also note that
// 'errno' is thread-specific, and hence MT-safe.

int
pw_acl4_get_from_posix_acls(const char *abspath, const int dir_flag, int *aclstat, acl4_t *acl4p, char *emsg_p, int *err_p)
{
    int i, rc, retval;
    mode_t posix_acl_equiv_mode;		// from acl_equiv_mode() triviality test (for possible chmod() use later)
    int posix_acl_aces, posix_dacl_aces;	// counts of ACEs in POSIX ACLs
    acl_t posix_acl = NULL, posix_dacl = NULL;	// These MUST by acl_free()'d before we leave (if non-NULL)
    char *posix_string = NULL;

    // *** PHASE 1 *** - Initializations

    // Initialize passed ACL4 and acl_free()-able variables ...
    assert (acl4p != NULL);
    acl4p->n_aces = 0;		// GUARANTEE error-free, valid ACL4 value (with zero entries) in any event
    errno = 0;
    *aclstat = 0;		// Assume no ACL or DACL

    // *** PHASE 2 *** - FETCH ACL, DACL, and respective ACE counts ...

#ifdef NEW_GET_BY_FD
    if ((posix_acl = acl_get_fd(fd)) == NULL) {			// Fetch ACL ...
        if (errno == EOPNOTSUPP) return (*err_p = EOPNOTSUPP);	// A smart caller will only suffer this once per directory!
    } else {
        PW_ACL_ERR("acl_get_fd()");
    }
#else
    // CHECK for ACL or DACL presence (without getting messy) ...
    rc = acl_extended_file_nofollow(abspath);
    if (rc == 0) {
        return (0);		// ACL4 is EMPTY (no ACL or DACL on file)
    } else if (rc < 0) {
        if (errno == EOPNOTSUPP) {
            return (*err_p = EOPNOTSUPP);	// A smart caller will only suffer this once per directory!
        } else {
            PW_ACL_ERR("acl_extended_file_nofollow()");
        }
    }
#endif

    // NOTE:  Linux always returns a non-NULL posix_acl, and a non-NULL posix_dacl on a directory,
    // but appears to be inconsistent with whether or not it will return a NULL posix_dacl on a
    // non-directory.
    if ((posix_acl = acl_get_file(abspath, ACL_TYPE_ACCESS)) == NULL) {
        PW_ACL_ERR("acl_get_file([ACL_TYPE_ACCESS])");
    }
    if ((posix_acl_aces = acl_entries(posix_acl)) < 0)
        PW_ACL_ERR("acl_entries(<acl>)");
    if (dir_flag) {
        if ((posix_dacl = acl_get_file(abspath, ACL_TYPE_DEFAULT)) == NULL)
            PW_ACL_ERR("acl_get_file([ACL_TYPE_DEFAULT])");
        if ((posix_dacl_aces = acl_entries(posix_dacl)) < 0)
            PW_ACL_ERR("acl_entries(<dacl>)");
    } else {
        posix_dacl = NULL;
        posix_dacl_aces = 0;
    }

    // Summarize results of POSIX ACL+DACL fetches ...
    if (posix_acl_aces) {	// Determine if input ACL is trivial (re-derived during ACL4 translation) ...
        if (acl_equiv_mode(posix_acl, &posix_acl_equiv_mode) == 0)
            *aclstat |= 1;	// trivial
        else
            *aclstat |= 2;	// non-trivial
    }
    if (posix_dacl_aces) *aclstat |= 4;

    // *** PHASE 3 *** - Output for 'xacls -sp' (Show POSIX) option ...

    if (pw_acls_SHOW_POSIX) {
        if (posix_acl_aces) {		// Display ACL input ...
    	    printf("# POSIX ACL has %d ACEs ...\n", posix_acl_aces);
    	    posix_string = acl_to_any_text(posix_acl, NULL, '\n', TEXT_ABBREVIATE|TEXT_NUMERIC_IDS|TEXT_SOME_EFFECTIVE|TEXT_SMART_INDENT);
    	    if (posix_string == NULL)
    	        PW_ACL_ERR("acl_to_any_text(<acl>)");
    	    printf("%s\n", posix_string);
    	    acl_free(posix_string);
            if (*aclstat & 1) printf("# POSIX ACL is trivial (mode 0%o)\n", posix_acl_equiv_mode);
        }
        if (posix_dacl_aces) {		// Display DACL input ...
    	    printf("# POSIX DACL has %d ACEs ...\n", posix_dacl_aces);
    	    posix_string = acl_to_any_text(posix_dacl, NULL, '\n', TEXT_ABBREVIATE|TEXT_NUMERIC_IDS|TEXT_SOME_EFFECTIVE|TEXT_SMART_INDENT);
    	    if (posix_string == NULL)
    	        PW_ACL_ERR("acl_to_any_text(<acl>)");
            printf("%s\n", posix_string);
            acl_free(posix_string);
        }
    }

    // *** PHASE 4 *** - POSIX-to-NFS4 translation

    // Add translated ACL and DACL to empty ACL4 (on error, subordinate function has set error vbls, so we just goto 'out') ...
    if (pw_acl_xlat_add_posix_acl_to_acl4(&posix_dacl, 1, dir_flag, acl4p, emsg_p, err_p) < 0)	// Add DACL first (!) ...
        goto out;
    if (pw_acl_xlat_add_posix_acl_to_acl4(&posix_acl, 0, dir_flag, acl4p, emsg_p, err_p) < 0)	// Add ACL ...
        goto out;
    pw_acl4_canonicalize(acl4p);								// Canonicalize ACL4 ...

    // Successful return value is number of ACL4 ACEs (>= 0) ...
    retval = acl4p->n_aces;

out:
    // Cleanup and return total number of ACL4 ACEs ...
    if (posix_acl) acl_free(posix_acl);
    if (posix_dacl) acl_free(posix_dacl);
    if (posix_string) acl_free(posix_string);
    return (retval);
}

// *** ^^^ THE PREVIOUS TWO FUNCTIONS ARE THE MAIN SUBSTANCE OF WHAT ALL THIS CODE IS REALLY ABOUT ^^^ ***

// pw_acl4_fwrite_binary() - Apply passed ACL4 to passwd path.  Called with acl4 or path NULL, does [p]close()
// after writing the EOD signature (two 32-bit zeros) to the pipe or file.
// NOTE: MUST call here to close output stream, because the output must first be finalized before the [p]close().
//
// MT-safe: Caller MUST own FILE * OutFILE handle, and pre-initialize it to NULL.
//
// Output is stream of ...
//	struct {
//		int acl_size;		// (zero means exit)
//		int path_size;		// (zero means exit)
//		acl4_t acl4;		// with only as many ace4 entries as used
//		char path[path_size];	// NUL-terminated string, padded to even 4-byte boundary
//	}

int
pw_acl4_fwrite_binary(acl4_t *acl4, const char *path, FILE **OutFILE_p, const char OUTmode, char *emsg_p, int *err_p)
{
    int retval;
    int rc, acl_size, path_size, padding_size, padded_path_size;
    static char padding[] = "????";
    static int zero = 0;
    FILE *OutFILE;	// Value from OutFILE_p

    retval = 0;								// Success default
    if (OutFILE_p == NULL) PW_ACL_ERR("pw_acl4_fwrite_binary() - NULL file!");
    if (*OutFILE_p == NULL) goto out;					// No-op

    OutFILE = *OutFILE_p;
    if (acl4 == NULL || path == NULL) {		// Close!
        // Output EOD as two zero-values 32-bit ints ...
        if (OutFILE != NULL) {
            if (fwrite(&zero, 1, 4, OutFILE) != 4)			PW_ACL_ERR("fwrite(<zero>)");
            if (fwrite(&zero, 1, 4, OutFILE) != 4)			PW_ACL_ERR("fwrite(<zero>)");
            if (OUTmode == 'p') {
                if (pclose(OutFILE))					PW_ACL_ERR("pclose(<OutFILE>)");
            } else {
                if (fclose(OutFILE))					PW_ACL_ERR("fclose(<OutFILE>)");
            }
            *OutFILE_p = NULL;			// Closed OK.
        }
        goto out;
    }
    if (acl4 == NULL || path == NULL) PW_ACL_ERR("pw_acl4_fwrite_binary() - bad args!");
    if (acl4->n_aces < 1) goto out;

    // Write to OutFILE ...
    acl_size = 4 + (acl4->n_aces * sizeof(ace4_t));
    path_size = strlen(path) + 1;
    padding_size = 4 - (path_size % 4);
    padded_path_size = path_size + padding_size;
    if (fwrite(&acl_size, 1, 4, OutFILE) != 4)				PW_ACL_ERR("fwrite(<acl_size>)");
    if (fwrite(&padded_path_size, 1, 4, OutFILE) != 4)			PW_ACL_ERR("fwrite(<padded_path_size>)");
    if (fwrite(acl4, 1, acl_size, OutFILE) != acl_size)			PW_ACL_ERR("fwrite(<acl4>)");
    if (fwrite(path, 1, path_size, OutFILE) != path_size)		PW_ACL_ERR("fwrite(<path>)");
    if (fwrite(padding, 1, padding_size, OutFILE) != padding_size)	PW_ACL_ERR("fwrite(<padding>)");

out:
    return (retval);
}
